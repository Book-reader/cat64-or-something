module assembler;

import common;
import lexer;

import std::io;
import std::collections::list;
import std::collections::tuple;

enum PseudoInstruction : (String name, String into)
{
//  CALL = { "call", "push " }
}

fn int main(String[] args) @if($feature(ASSEMBLER))
{
  if (args.len != 3)
  {
    io::eprintn("must pass input file name and output file name");
    return 1;
  }
  char[] file_data = file::load_new(args[1])!!;
  File out_file = file::open(args[2], "wb")!!;

  usz data_ptr = 0;
  io::printfn("Assembling:\n---------\n%s\n---------", (String)file_data);
  Tokens! lexed = lexer::lex(file_data);
  if (catch err = lexed)
  {
    common::error("Error while lexing tokens: %s", err);
  }

  foreach (tok : lexed)
  {
    io::printfn("token '%s':%s", tok.lexme, tok.type);
  }

  List(<char>) data =  validate_gen(lexed);
  io::printn("generated bytes:");
  foreach (ch : data)
  {
    io::printf("%.2x", ch);
  }
  io::printn();

  out_file.write(data.array_view())!!;
  out_file.close()!!;

  return 0;
}

fn List(<char>) validate_gen(Tokens lexed)
{
  List(<char>) generated;

  Tokens sequence; 

  foreach (token : lexed)
  {
    io::printfn("val: %s", token);
    if (token.type == LABEL || token.type == LABEL_DECL)
    {
      common::error("Labels are not implemented yet");
    }
    if (sequence.len() == 0 || ( token.type != INSTRUCTION && token.type != LABEL_DECL))
    {
      sequence.push(token);
    }
    else
    {
      List(<char>)! new = validate_sequence(sequence);
      if (catch err = new)
      {
        common::error("Error while parsing tokens '%s': %s", sequence.array_view(), err);
      }
      generated.add_all(&new);
      sequence.clear();
      sequence.push(token);
    }
  }

  return generated;
}

fault ValidationError
{
  TOO_MANY_ARGUMENTS,
  TOO_FEW_ARGUMENTS,
  UNKNOWN_BIT_SIZE,
  NUMBER_TOO_LARGE,
  INVALID_INSTRUCTION_SOMETHING_VERY_BROKEN,
  INVALID_ARGUMENT,
  INVALID_JIF_COND,
  GENERIC,
}

def InstT_And_Width = Tuple(<InstructionType, BitWidth>);

fn InstT_And_Width! validate_instruction(Token tok)
{
  $foreach ($instruction : InstructionType.values)
  if (tok.lexme.len >= $instruction.name.len && tok.lexme[0:$instruction.name.len] == $instruction.name)
  {
    
    if ($instruction.sized == false)
    {
      return {$instruction, W8};
    }
    USize size = tok.lexme[$instruction.name.len+1..].to_int()!;

    BitWidth width;
    switch (size)
    {
      case BitWidth.W8.bit_size:
        width = W8;
      case BitWidth.W16.bit_size:
        width = W16;
      case BitWidth.W32.bit_size:
        width = W32;
      case BitWidth.W64.bit_size:
        width = W64;
      default:
        return ValidationError.UNKNOWN_BIT_SIZE?;
    }
    return {$instruction, width};
    
    //{
    //  return true;
    //}*/
//    return false;
    }
  $endforeach
  return ValidationError.INVALID_INSTRUCTION_SOMETHING_VERY_BROKEN?;
}

fn List(<Tokens>)! validate_arguments(InstructionType type, Token[] args)
{
  io::printfn("args: %s", args);
  List(<Tokens>) args_val;
  Tokens collected;
  int args_count = 0;
  foreach (i, tok : args)
  {
     if (collected.len() != 0 && tok.type == ARG_SEP)
     {
       validate_argument(collected)!;
       args_val.push(collected);
       args_count ++;
       collected = {};
     }
     else if (tok.type != ARG_SEP)
     {
       collected.push(tok);
     }
  }
  if (collected.len() != 0)
  {
    validate_argument(collected)!;
    args_val.push(collected);
    args_count ++;
  }
  if (type.args_len < args_count) return ValidationError.TOO_MANY_ARGUMENTS?;
  if (type.args_len > args_count) return ValidationError.TOO_FEW_ARGUMENTS?;

  return args_val;
}

// This will eventually be used for evaluating stuff like 'mov.8 r0, [label + 5]'
fn void! validate_argument(Tokens arg)
{
   io::printfn("arg: %s", arg);
   if ( arg.len() == 1 && ( arg[0].type == CHAR || arg[0].type == NUMBER || arg[0].type == LABEL || arg[0].type == REGISTER ) ||
          ( arg.len() == 2 && arg[0].type == DEREF && ( arg[1].type == NUMBER || arg[1].type == LABEL || arg[1].type == REGISTER )))
   {
     return;
   }
   else
   {
     return ValidationError.INVALID_ARGUMENT?;
   }
}

fn Instruction! build_instruction(InstT_And_Width type, List(<Tokens>) args)
{
  Instruction inst = {.real = true, .type = type.first, .width = type.second};

  assert (args.len() <= 2);
  foreach (i, arg : args)
  {
    assert (arg.len() <= 2);
    OpType op_type;
    if (arg[0].type == DEREF)
    {
      switch (arg[1].type)
      {
        case NUMBER:
        case LABEL:
          op_type = PTR;
        case REGISTER:
          op_type = REGPTR;
        default:
          common::error("Unsupported deref: %s", arg[1].type);
      }
    }
    else
    {
      switch (arg[0].type)
      {
        case NUMBER:
        case CHAR:
        case LABEL:
          op_type = NUM;
        case REGISTER:
          op_type = REG;
        default:
          common::error("Unsupported type: %s", arg[0].type);
      }
    }
    if (i == 0)
    {
      inst.dst_type = op_type;
    }
    else
    {
      inst.src_type = op_type;
    }
  }

  if (inst.type == JIF)
  {
    int cond = args[0][0].lexme.to_int()!!;
    if (cond >= Condition.elements)
    {
      return ValidationError.INVALID_JIF_COND?;
    }
    inst.jif_cond = (Condition)cond;
    args.remove_first();
  }

  return inst;
}

fn List(<char>)! build_arguments(InstT_And_Width inst_type, List(<Tokens>) args)
{
  List(<char>) args_ch;

  if (inst_type.first == JIF)
  {
    args_ch.add_array(common::to_bytes(W64, args[0][0].lexme.to_ulong()!));
  }
  else
  {
    assert (args.len() <= 2);
    for (int i = (int)args.len() - 1; i >= 0; i--)
    {
      io::printfn("%s %s", i, args.len());
      Tokens arg = args[i];
      foreach (tok : arg)
      {
        switch (tok.type)
        {
          case REGISTER:
            args_ch.add_array(common::to_bytes(W8, lexer::REG_NAMES[..].index_of(tok.lexme)!!));
          case NUMBER:
            char[] result;
            switch (inst_type.second)
            {
              case W8:
                result = common::to_bytes(inst_type.second, tok.lexme.to_uchar()!, true);
              case W16:
                result = common::to_bytes(inst_type.second, tok.lexme.to_ushort()!, true);
              case W32:
                result = common::to_bytes(inst_type.second, tok.lexme.to_uint()!, true);
              case W64:
                result = common::to_bytes(inst_type.second, tok.lexme.to_ulong()!, true);
                for (int j = 0; j < inst_type.second.size; j++)
                {
                  io::printf("%.2x", result[j]);
                }
                io::printn();
                io::printfn("W64: %.16x %.16x", common::to_usize(W64, result), tok.lexme.to_uchar()!);
            }
            args_ch.add_array(result);
            //for ()
            io::printfn("%s: %s", inst_type.second, common::to_usize(inst_type.second, args_ch.array_view()[args_ch.len() - inst_type.second.size..]));
//            io::printfn();
          case CHAR:
             io::printfn("found char %c:%.2x", tok.lexme[0], tok.lexme[0]);
             args_ch.push(tok.lexme[0]);
             io::printfn("char2 %c %.2x", args_ch[args_ch.len()-1], args_ch[args_ch.len()-1]);
          case DEREF:
            break;
          default:
            common::error("Unhandled token type: %s (%s)", tok.type, tok.lexme);
        }
      }
    }
  }

  return args_ch;
}

fn List(<char>)! validate_sequence(Tokens sequence)
{
  InstT_And_Width inst_type = validate_instruction(sequence[0])!;
  List(<char>) data;

  List(<Tokens>) args = validate_arguments(inst_type.first, sequence.array_view()[1..])!;

  Instruction inst = build_instruction(inst_type, args)!;

  $assert(InstSize.sizeof == BitWidth.W16.size);
  data.add_array(common::to_bytes(W16, (InstSize)inst));

  data.add_all(&&build_arguments(inst_type, args)!);

  return data;
}
