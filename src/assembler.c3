module assembler;

import common;
import lexer;

import std::io;
import std::collections::list;
import std::collections::tuple;

def LProg = List(<InstTok>);

struct InstTok(Printable)
{
  InstructionType type;
  BitWidth inst_width;
  String label;
  TokArgType arg_dst_type;
  TokArgType arg_src_type;
  TokenArg arg_dst;
  TokenArg arg_src;
}

fn usz InstTok.byte_offset(&self, LProg* prog, usz own_idx, bool start = true)
{
  usz count;
  for (int i = 0; i < own_idx; i++)
  {
    InstTok inst = prog.get(i);
    count += inst.size();
  }
  return count;
}

fn usz InstTok.size(&self)
{
  return Instruction.sizeof + self.arg_dst_type.size + self.arg_src_type.size; 
}

fn usz! InstTok.to_format(&self, Formatter* formatter) @dynamic
{
  usz! n = formatter.printf("%s.%s:[ ", self.type, self.inst_width);
  $foreach ($arg : {"dst", "src"})
    n += formatter.printf("(%s", self.$eval("arg_" +++ $arg +++ "_type"));
    if OUTER: (true)
    {
      $foreach ($width : TokArgType.values)
        if (self.$eval("arg_" +++ $arg +++ "_type") == $width)
        {
          n += formatter.printf(":%s %s) ", $width.size, self.$eval("arg_" +++ $arg).$eval("as_" +++ $width.nameof));
          break OUTER;
        }
      $endforeach
    }

  $endforeach
  if (self.label.len > 0)
  {
    n += formatter.printf("l:%s ", self.label);
  }

  n += formatter.print("]");

  return n; 
}

union TokenArg
{
  char as_NONE;
  char as_REG;
  char as_REGPTR;
  char as_W8;
  ushort as_W16;
  uint as_W32;
  ulong as_W64;
  String as_LABEL;
}

enum TokArgType : char (usz size)
{
  NONE = 0,
  REG = 1,
  REGPTR = 1,
  W8 = 1,
  W16 = 2,
  W32 = 4,
  W64 = 8,
  LABEL = 8,
}


fn int main(String[] args) @if($feature(ASSEMBLER))
{
  if (args.len != 3)
  {
    io::eprintn("must pass input file name and output file name");
    return 1;
  }
  char[] file_data = file::load_new(args[1])!!;
  File out_file = file::open(args[2], "wb")!!;

  usz data_ptr = 0;
  io::printfn("Assembling:\n---------\n%s\n---------", (String)file_data);
  Prog! lexed = lexer::lex(file_data);
  if (catch err = lexed)
  {
    common::error("Error while lexing tokens: %s", err);
  }

  /*
   * mov.64, r1, 0xff
   * main:
   *   mov.8, r0, [r1]
   *   printc.8
   *   add.64, r1, 1
   *   jmp main
  */
  LProg test;
  test.add_array({
    {MOV, W64, "", REG, W64, {.as_REG = 1}, {.as_W64 = 0xff}},
    {MOV, W8, "main", REG, REGPTR, {.as_REG = 0}, {.as_REGPTR = 1}},
    {PRINTC, W8, "", NONE, NONE, {}, {}},
    {ADD, W64, "", REG, W64, {.as_REG = 1}, {.as_W64 = 1}},
    {JMP, W8, "", LABEL, NONE, {.as_LABEL = "main"}, {}},
  });

  foreach (idx, i : test)
  {
    io::printfn("%s %s: size:%s offset:%s", idx, i, i.size(), i.byte_offset(&test, idx));
  }

  foreach (expr : lexed) foreach (tok : expr) io::printfn("token '%s':%s", tok.lexme, tok.type);
/*
  List(<char>) data;
  data.new_init();
  defer data.free();

  validate_gen(&data, lexed);

  io::printn("generated bytes:");
  foreach (ch : data)
  {
    io::printf("%.2x", ch);
  }
  io::printn();

  out_file.write(data.array_view())!!;
  out_file.close()!!;
*/

  return 0;
}
/*
fn void validate_gen(List(<char>)* generated, Tokens lexed) // TODO: FIX
{

  Tokens sequence; 

  for (usz i = 0; i < lexed.len(); )
  {
    io::printfn("val: %s", lexed[i]);
    if (lexed[i].type == INSTRUCTION)
    {
      sequence.push(lexed[i]);
      i++;
      while (i < lexed.len() && lexed[i].type != INSTRUCTION)
      {
        sequence.push(lexed[i]);
        i++;
      }
      if (catch err = validate_sequence(generated, sequence))
      {
        common::error("Error while parsing tokens '%s': %s", sequence.array_view(), err);
      }
      sequence.clear();
    }
    else if (lexed[i].type == LABEL_DECL)
    {
      lexer::labels.set(lexed[i].lexme[..lexed[i].lexme.len - 2], generated.len() + 1);
      i++;
    }
    else
    {
      common::error("I probably did something stupid %s", lexed[i].type);
    }
  }
}

fault ValidationError
{
  TOO_MANY_ARGUMENTS,
  TOO_FEW_ARGUMENTS,
  UNKNOWN_BIT_SIZE,
  NUMBER_TOO_LARGE,
  INVALID_INSTRUCTION_SOMETHING_VERY_BROKEN,
  INVALID_ARGUMENT,
  INVALID_JIF_COND,
  GENERIC,
}

def InstT_And_Width = Tuple(<InstructionType, BitWidth>);

fn InstT_And_Width! validate_instruction(Token tok)
{
  $foreach ($instruction : InstructionType.values)
  if (tok.lexme.len >= $instruction.name.len && tok.lexme[0:$instruction.name.len] == $instruction.name)
  {
    
    if ($instruction.sized == false)
    {
      return {$instruction, W8};
    }
    USize size = tok.lexme[$instruction.name.len+1..].to_int()!;

    BitWidth width;
    switch (size)
    {
      case BitWidth.W8.bit_size:
        width = W8;
      case BitWidth.W16.bit_size:
        width = W16;
      case BitWidth.W32.bit_size:
        width = W32;
      case BitWidth.W64.bit_size:
        width = W64;
      default:
        return ValidationError.UNKNOWN_BIT_SIZE?;
    }
    return {$instruction, width};
    
    //{
    //  return true;
    //}
//    return false;
    }
  $endforeach
  return ValidationError.INVALID_INSTRUCTION_SOMETHING_VERY_BROKEN?;
}

fn List(<Tokens>)! validate_arguments(InstructionType type, Token[] args)
{
  io::printfn("args: %s", args);
  List(<Tokens>) args_val;
  Tokens collected;
  int args_count = 0;
  foreach (i, tok : args)
  {
     if (collected.len() != 0 && tok.type == ARG_SEP)
     {
       validate_argument(collected)!;
       args_val.push(collected);
       args_count ++;
       collected = {};
     }
     else if (tok.type != ARG_SEP)
     {
       collected.push(tok);
     }
  }
  if (collected.len() != 0)
  {
    validate_argument(collected)!;
    args_val.push(collected);
    args_count ++;
  }
  if (type.args_len < args_count) return ValidationError.TOO_MANY_ARGUMENTS?;
  if (type.args_len > args_count) return ValidationError.TOO_FEW_ARGUMENTS?;

  return args_val;
}

// This will eventually be used for evaluating stuff like 'mov.8 r0, [label + 5]'
fn void! validate_argument(Tokens arg)
{
   io::printfn("arg: %s", arg);
   Tokens collected;
   collected.new_init();
   defer collected.free();

   foreach (token : arg)
   {
     switch (token.type)
     {
       default:
         collected.push(token);
       case LABEL_DECL:
     }
   }
   if ( collected.len() == 1 && ( collected[0].type == CHAR || collected[0].type == NUMBER || collected[0].type == LABEL || collected[0].type == REGISTER ) ||
          ( collected.len() == 2 && collected[0].type == DEREF && ( collected[1].type == NUMBER || collected[1].type == LABEL || collected[1].type == REGISTER )))
   {
     return;
   }
   else
   {
     return ValidationError.INVALID_ARGUMENT?;
   }
}

fn Instruction! build_instruction(InstT_And_Width type, List(<Tokens>) args)
{
  Instruction inst = {.real = true, .type = type.first, .width = type.second};

  assert (args.len() <= 2);
  foreach (i, arg : args)
  {
    assert (arg.len() <= 2);
    OpType op_type;
    if (arg[0].type == DEREF)
    {
      switch (arg[1].type)
      {
        case NUMBER:
          op_type = PTR;
        case REGISTER:
          op_type = REGPTR;
        case LABEL:
          op_type = PTR;
          inst.jif_rel = true;
        default:
          common::error("Unsupported deref: %s", arg[1].type);
      }
    }
    else
    {
      switch (arg[0].type)
      {
        case NUMBER:
        case CHAR:
          op_type = NUM;
        case REGISTER:
          op_type = REG;
        case LABEL:
          op_type = NUM;
          inst.jif_rel = true;

        default:
          common::error("Unsupported type: %s", arg[0].type);
      }
    }
    if (i == 0)
    {
      inst.dst_type = op_type;
    }
    else
    {
      inst.src_type = op_type;
    }
  }

  if (inst.type == JIF)
  {
    int cond = args[0][0].lexme.to_int()!!;
    if (cond >= Condition.elements)
    {
      return ValidationError.INVALID_JIF_COND?;
    }
    inst.jif_cond = Condition.from_ordinal(cond);
    args.remove_first();
    if (lexer::labels.has_key(args[0][0].lexme))
    {
      inst.jif_rel = true;
    }
  }

  return inst;
}

fn void! build_arguments(List(<char>)* args_ch, InstT_And_Width inst_type, List(<Tokens>) args)
{

  if (inst_type.first == JIF)
  {
    switch (args[0][0].type)
    {
      case NUMBER:
        args_ch.add_array(common::to_bytes(W64, args[0][0].lexme.to_ulong()!));
      case LABEL:
        /*if (lexer::labels.has_key(args[0][0].lexme))
        {
          args_ch.add_array(common::to_bytes(W64, lexer::labels.get(args[0][0].lexme)!! - args_ch.len()));
        }
        else
        {
           common::error("label does not exist: %s", args[0][0].lexme);
        }*/
        io::printfn("label offset is %d", (isz)lexer::labels.get(args[0][0].lexme)!! - args_ch.len());

io::printfn("%s %s", args_ch.array_view(), args_ch.len());
foreach (ch : args_ch)
{
  io::printf("%.2x", ch);
}
io::printn();

        io::printfn("weufhewiufewiufhewhewiufhewifuwehfiuewhfiewhf REMEMBER TO MAKE RELATIVE (isz)lexer::labels.get(args[0][0].lexme)! - args_ch.len()");
        args_ch.add_array(common::to_bytes(W64, (isz)lexer::labels.get(args[0][0].lexme)!! - args_ch.len()));

      default:
        common::error("no");
    }
  }
  else
  {
    assert (args.len() <= 2);
    for (int i = (int)args.len() - 1; i >= 0; i--)
    {
      io::printfn("%s %s", i, args.len());
      Tokens arg = args[i];
      foreach (tok : arg)
      {
        switch (tok.type)
        {
          case REGISTER:
            args_ch.add_array(common::to_bytes(W8, lexer::REG_NAMES[..].index_of(tok.lexme)!!));
          case NUMBER:
            char[] result;
            io::printfn("%s", inst_type.second);
            switch (inst_type.second)
            {
              case W8:
                result = common::to_bytes(inst_type.second, tok.lexme.to_uchar()!, true);
              case W16:
                result = common::to_bytes(inst_type.second, tok.lexme.to_ushort()!, true);
              case W32:
                result = common::to_bytes(inst_type.second, tok.lexme.to_uint()!, true);
              case W64:
                result = common::to_bytes(inst_type.second, tok.lexme.to_ulong()!, true);
            }
            args_ch.add_array(result);
            //for ()
            io::printfn("%s: %s", inst_type.second, common::to_usize(inst_type.second, args_ch.array_view()[args_ch.len() - inst_type.second.size..]));
//            io::printfn();
          case CHAR:
             io::printfn("found char %c:%.2x", tok.lexme[0], tok.lexme[0]);
             args_ch.push(tok.lexme[0]);
             io::printfn("char2 %c %.2x", args_ch[args_ch.len()-1], args_ch[args_ch.len()-1]);
          case DEREF:
            break;
          case LABEL:
            io::printfn("label offset is %.16x", (isz)lexer::labels.get(args[0][0].lexme)!! - args_ch.len());
            io::printfn("weufhewiufewiufhewhewiufhewifuwehfiuewhfiewhf REMEMBER TO MAKE RELATIVE (isz)lexer::labels.get(tok.lexme)! - args_ch.len()");
            args_ch.add_array(common::to_bytes(W64, (isz)lexer::labels.get(args[0][0].lexme)!! - args_ch.len(), true));
          case LABEL_DECL:
            lexer::labels.set(tok.lexme[..tok.lexme.len - 2], args_ch.len() + 1);
          default:
            common::error("Unhandled token type: %s (%s)", tok.type, tok.lexme);
        }
      }
    }
  }


}

fn void! validate_sequence(List(<char>)* data, Tokens sequence)
{
  InstT_And_Width inst_type = validate_instruction(sequence[0])!;

  List(<Tokens>) args = validate_arguments(inst_type.first, sequence.array_view()[1..])!;

  Instruction inst = build_instruction(inst_type, args)!;

  $assert(InstSize.sizeof == BitWidth.W16.size);
  data.add_array(common::to_bytes(W16, (InstSize)inst));

  build_arguments(data, inst_type, args)!; 
}
*/
